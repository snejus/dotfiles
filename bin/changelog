#!/usr/bin/env bash

#   Try finding the changelog of a Python package and render it with glow (markdown) or
#   pygments (md and rst), if they are installed.
#
#   Tested with bash and zsh. It isn't POSIX-compatible however.
#
#   $ git clone <gist-url>
#   $ cd changelog
#   $ chmod a+x changelog
#   $ ln -is `realpath changelog` ~/.local/bin/changelog
#
#   USAGE:
#
#       $ changelog <package-name> [-p|--pager] [-P|--plain] [-s|--silent] [-h|--help]
#
#   (or just source the function to your environment)
#
#   It queries PyPi and reads the 'Home-page' field, therefore it depends on libraries
#   to provide correct URLs to their github repos. For those which don't, there's a
#   PROJECTS variable that allows to hard-code the links.
#
#   It uses pypi-cli if it's available (since it works regardless of your environment).
#   If it isn't available, it tries using pip, however this works only if you have the
#   package in your environment. Though, pip works for private packages, while pypi-cli
#   doesn't.
#
#   If the changelog isn't found in the repo, it prints out the README, given it exists.
#
#   If you want to access private repos and increase Github API's rate limits,
#
#       $ export GITHUB_TOKEN=<your github token>
#
#   Would recommend installing glow (go) and pygments (python) for pretty output and having
#
#       $ alias clog='changelog -p'
#

# flake8: https://gitlab.com/pycqa/flake8/-/tree/master/docs/source/release-notes - non-standard
declare -A PROJECTS
# repos that contain CHANG* file in their root (anything that starts with `CHANG`, case-insensitive)
PROJECTS[httpie]=httpie/httpie
PROJECTS[poetry]=python-poetry/poetry
PROJECTS[feh]=derf/feh
PROJECTS[prettier]=prettier/prettier

declare -A LINKS
LINKS[markdown]=Python-Markdown/markdown/master/docs/change_log/release-3.3.md
LINKS[docker-compose]=https://github.com/docker/compose/blob/release/CHANGELOG.md
LINKS[djangorestframework]=encode/django-rest-framework/master/docs/community/release-notes.md
LINKS[pytest]=pytest-dev/pytest/master/doc/en/changelog.rst
LINKS[pytz]=stub42/pytz/master/tz/NEWS
LINKS[whitenoise]=evansd/whitenoise/master/docs/changelog.rst

VERBOSE=1
PAGER=0
PLAIN=0
DEFAULT_PIP="$(pass show main-repo-pip)"  # path to the default venv pip for private packages

pspeak() {
    # - printf speak - (or polite-speak) - mind the VERBOSE flag
    if [[ -n $VERBOSE ]]; then
        printf "$@"
    fi
}

good() {  # bold green
    printf $'\e[1;32m%s\e[0m' "$1"
}

okay() {  # bold orange
    printf $'\e[1;33m%s\e[0m' "$1"
}

oh() {  # bold red
    printf $'\e[1;31m%s\e[0m' "$1"
}

happy() {
    pspeak '%s %s\n' "$(good "$1")" "$2"
}

hmmm() {
    printf >&2 '%s %s\n' "$(okay WARNING:)" "$1"
}

uhoh() {
    printf >&2 '%s %s\n' "$(oh ERROR:)" "$1"
}

get() {
    url=$1
    curl -L -s -u "username:$GITHUB_TOKEN" "$(tr -d ' "' <<< "$url")"
}

show() {
# Markdown: glow -> pygments -> plain
# Restructured text: pygments -> plain
    url="$1"
    if [[ $PLAIN -eq 1 ]]; then
        get "$url"
        return
    fi

    format="rst"
    grep -vq ".rst" <<< "$url" && format="md"
    if [[ $format == "md" ]] && command -v glow &> /dev/null; then
        get "$url" | glow -s dark - && return
    fi

    if command -v pygmentize &> /dev/null; then
        get "$url" | pygmentize -l "$format" -O style=monokai
    else
        get "$url"
    fi
}

render() {
    url=$1

    if [[ $PAGER -eq 0 ]]; then
        show "$url" 1>&2
    else
        printf '%s' "$(show "$url")" | less -R 1>&2
    fi
}

try_with_pypi() {
    pypi info "$pkg" 2> /dev/null | sed -n "/github/p; /pypi/p; s/.* //; s/\/tree\/master//"
}

get_homepage() {
    pkg=$1
    if command -v pypi > /dev/null; then
        details=$(try_with_pypi "$pkg")
        if [[ -n $details ]]; then
            printf '%s' "$details"
            return
        fi
        hmmm "pypi didn't find the package: Trying pip"
    else
        hmmm "pypi executable not found: Using pip"
    fi

    pipbin=$DEFAULT_PIP
    if [[ -z $pipbin ]]; then
        pipbin=pip
    fi
    $pipbin show "$pkg" 2> /dev/null | sed -n "/Home/s/.*: //p"
}

try_non_github_homepage() {
    curl -s "$1" | grep -oPm1 "github.com/\K[^/]*/[^/\" ]*"
}

get_info_source() {
    repo_name=$1
    repofilelist=$(get "https://api.github.com/repos/$repo_name/contents" |
        jq '.[] | [.name, .download_url] | @tsv')

    changelogurl=$(grep -i -oP '(history.*|news.*|chang.*).*\Khttps[^ "]*"' <<< "$repofilelist")
    if [[ -n $changelogurl ]]; then
        pspeak '%s the changelog\n' "$(good Found)"
        export INFOSOURCE="$changelogurl"
        return
    fi

    hmmm "Failed to find the changelog in the repository root. Looking for a readme instead."
    readmeurl=$(grep -i -oPm1 "readme.*\Khttps[^\"]*" <<< "$repofilelist")
    if [[ -z $readmeurl ]]; then
        uhoh "$pkg doesn't have a readme"
        exit 1
    fi
    pspeak '%s the readme\n' "$(good Found)"
    export INFOSOURCE="$changelogurl"
}

changelog() {
    pkg=$1
    pspeak 'Looking for %s changelog\n' "$(good "$pkg")"
    if [[ -z $GITHUB_TOKEN ]]; then
        hmmm "GITHUB_TOKEN is not found in the environment"
    fi

    directlink="${LINKS[$pkg]}"
    if [[ -n $directlink ]]; then
        happy "Link to the changelog is already defined"
        render "https://raw.githubusercontent.com/$directlink"
        exit 0
    fi

    predefined="${PROJECTS[$pkg]}"
    if [[ -n $predefined ]]; then
        pspeak '%s the package repo in the defined list\n' "$(good Found)"
        projectname=$predefined
    else
        homepage="$(get_homepage "$pkg")"
        if [[ -z $homepage ]]; then
            uhoh "Pip failed to find the package"
            exit 1
        fi
        happy "Home-page:" "$homepage"
        projectname=$(sed -n "/github/s/.*\.com\///p" <<< "$homepage")
        if [[ -z $projectname ]]; then
            pspeak 'Sad, the home page is not a Github URL.\n'
            pspeak 'Lets just try something quick though ...\n'
            projectname=$(try_non_github_homepage "$homepage")
            if [[ -n $projectname ]]; then
                happy Bingo
            else
                uhoh "Could not find $pkg github repository. Check out its home page instead: $homepage"
                exit 1
            fi
        fi
    fi
    happy "Github project:" "$projectname"
    get_info_source "$projectname"
    render "$INFOSOURCE"
    exit 0
}

chill() {
    printf $'\e[1;34m%s\e[0m' "$1"
}

comment() {
    printf $'\e[1;38m%s\e[0m' "$1"
}

show_help() {
    cat <<-EOF

  » $(chill changelog) $(okay "[options]") $(good package) $(okay "[options]")

    ╰─ $(okay "-p, --pager")       $(comment "# page the output")
    ╰─ $(okay "-P, --plain")       $(comment "# do not apply post-processing (keep it ugly)")
    ╰─ $(okay "-s, --silent")      $(comment "# only print errors and the output")
    ╰─ $(okay "-h, --help")        $(comment "# display help")

EOF
    exit 0
}

unhappy_input() {
    uhoh "$1\n"
    chill "    changelog"
    oh " package\n\n"
}

if test $# -eq 0; then
    show_help
else
    while test $# -ne 0; do
        case $1 in
            -p|--pager) PAGER=1 ;;
            -P|--plain) PLAIN=1 ;;
            -s|--silent) VERBOSE= ;;
            -h|--help) show_help; exit ;;
            *)
            if [[ -z $pkg ]]; then
                pkg="$1"
            else
                unhappy_input "Please provide a single package name"
                exit 1
            fi; ;;
        esac
        shift
    done
    [[ -z $pkg ]] && unhappy_input "Please provide a package name"  && exit 1
    changelog "$pkg"
fi
# vim:ft=sh
